---
layout: post
title: 가상 스레드
date: 2025-05-01
last_modified_at: 2025-05-01
tags: [CS]
toc: true
---

## 📑 **Table Of Contents**

- [1. ⚙ 스레드와 가상 스레드의 차이](#thread-vs-virtual-thread)
  - [스레드의 기본 개념](#thread)
  - [가상 스레드의 기본 개념](#virtual-thread)
- [2. ⚙ 가상 스레드의 동작 원리와 스케줄링](#how-virtual-threads-work)
- [3. ⚙ 가상 스레드와 기존 동시성 모델 비교](#compare-concurrency-models)
- [4. ⚙ 가상 스레드의 장점](#advantages-of-virtual-threads)
- [5. ⚙ 실제 코드 예시 및 활용 사례](#examples-and-usecases)
- [6. ⚙ 가상 스레드를 사용 시 고려할 점 및 한계](#considerations-and-limitations)
- [7. ⚙ 성능 및 자원 관리](#performance-and-resource)
- [8. 🏁 마치며](#conclusion)

![virtual_thread_1.png](/images/posts/2025-05-01-virtual-thread/virtual_thread.png)

## 1. ⚙ 스레드와 가상 스레드의 차이 {#thread-vs-virtual-thread}

### 스레드의 기본 개념 {#thread}

- 운영체제 (OS) 커널에서 관리하는 실행 단위를 뜻합니다.
- 각 스레드는 고유한 스택과 레지스터를 가지며, CPU 시간을 할당받아 코드를 실행합니다.
- OS 스레드는 블로킹 I/O 작업 시 해당 스레드가 대기 상태에 들어가 CPU Resource를 낭비할 수 있습니다.
- <u>생성 및 관리 비용이 비교적 높다는 단점이 있습니다.</u>

### 가상 스레드의 기본 개념 {#virtual-thread}

- JVM (Java Virtual Machine) 수준에서 관리되는 경량 스레드를 뜻합니다.
- OS 스레드와 1:1 매핑이 아닌, 여러 가상 스레드가 하나의 OS 스레드에서 실행될 수 있습니다.
- 블로킹 I/O 작업 시 다른 가상 스레드가 실행될 수 있어 CPU Resource 낭비를 줄일 수 있습니다.
- <u>생성 및 관리 비용이 비교적 낮은 장점이 있습니다.</u>

## 2. ⚙ 가상 스레드의 동작 원리와 스케줄링 {#how-virtual-threads-work}

- 가상 스레드는 JVM 또는 사용자 수준(User-level)에서 관리되는 경량 스레드입니다.
- 여러 가상 스레드가 소수의 커널(플랫폼) 스레드 위에서 협력적으로 실행됩니다 (M:N 매핑).
- Java의 경우, ForkJoinPool 등 내부 스케줄러가 가상 스레드를 관리하며, 컨텍스트 스위칭 비용이 매우 작고 스레드 생성/소멸 비용이 거의 없습니다.
- 블로킹 I/O 작업이 발생하면 해당 가상 스레드는 대기 상태로 전환되고, 다른 가상 스레드가 즉시 실행될 수 있습니다.

## 3. ⚙ 가상 스레드와 기존 동시성 모델 비교 {#compare-concurrency-models}

- **OS 스레드(1:1 모델)**: 각 사용자 스레드가 하나의 커널 스레드에 매핑. 생성/관리 비용이 높고, 대규모 동시성에 한계.
- **유저 스레드(N:1 모델)**: 여러 사용자 스레드가 하나의 커널 스레드에 매핑. 커널 개입이 적으나, 병렬성 제한.
- **가상 스레드(M:N 모델)**: 여러 가상 스레드가 소수의 커널 스레드에 매핑. 높은 동시성과 효율성 제공.
- **Go 루틴(Goroutine)**, **Python asyncio**, **Node.js 이벤트 루프** 등과 유사한 개념이나, Java 가상 스레드는 기존 스레드 API와 완전히 호환됨.

## 4. ⚙ 가상 스레드의 장점 {#advantages-of-virtual-threads}

- **향상된 성능**: 대규모 동시성 처리 시스템에서 더 높은 처리량과 응답성을 제공합니다.
- **간결하고 명확한 코드**: 블로킹 코드를 사용하면서도 비동기 프로그래밍의 장점을 누릴 수 있습니다.
- **높은 자원 효율성**: CPU 및 메모리 자원을 효율적으로 활용하여 시스템 비용을 절감할 수 있습니다.
- **스레드 생성/소멸 비용이 매우 낮음**: 수십만~수백만 개의 스레드도 부담 없이 생성 가능.

## 5. ⚙ 실제 코드 예시 및 활용 사례 {#examples-and-usecases}

### Java 가상 스레드 생성 예시 (JDK 21 기준)

```java
// Java 가상 스레드 생성
Thread.startVirtualThread(() -> {
    System.out.println("Hello from virtual thread!");
});
```

### 활용 사례
- 대규모 서버, 웹 서비스, 마이크로서비스 등에서 대량의 동시 요청 처리
- 비동기 네트워크 서버, 데이터베이스 클라이언트 등 I/O 중심 애플리케이션

## 6. ⚙ 가상 스레드를 사용 시 고려할 점 및 한계 {#considerations-and-limitations}

- **런타임 환경**: JDK 19 이상에서 정식 지원 (Project Loom)
- **네이티브 코드/JNI, 특정 라이브러리와의 호환성 이슈**: 일부 네이티브 라이브러리는 가상 스레드와 잘 동작하지 않을 수 있음
- **스레드 로컬(Thread-local) 변수**: 사용 시 주의 필요 (스케줄링 특성상 예기치 않은 동작 가능)
- **CPU 집약적인 작업**: 가상 스레드는 블로킹 I/O에 최적화되어 있으며, CPU 바운드 작업에는 큰 이점이 없음
- **디버깅/모니터링**: 기존 도구와의 호환성, 새로운 진단 기법에 대한 학습 필요

## 7. ⚙ 성능 및 자원 관리 {#performance-and-resource}

- **메모리 사용량**: 가상 스레드는 스택 크기가 작아 수십만 개 생성 가능 (기본 256KB, 필요 시 동적 확장)
- **컨텍스트 스위칭 오버헤드**: 커널 스레드 대비 매우 낮음
- **자원 관리**: 효율적이지만, 무분별한 스레드 생성은 오히려 시스템 자원 고갈을 초래할 수 있으므로 주의

## 8. 🏁 마치며 {#conclusion}

가상 스레드는 JVM 수준에서 관리되는 경량 스레드로, 대규모 동시성 처리 시스템에서 높은 성능과 자원 효율성을 제공합니다. 블로킹 코드를 사용하면서도 비동기 프로그래밍의 장점을 누릴 수 있으며, 간결하고 명확한 코드 작성을 가능하게 합니다.

다만, 런타임 환경이나 디버깅 및 모니터링, CPU 집약적인 작업, 네이티브 라이브러리와의 호환성 등은 신중하게 고려해야 하며, 시스템 특성과 요구사항에 맞춰 도입하는 것이 중요합니다.